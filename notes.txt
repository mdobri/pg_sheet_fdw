Explanation from the pg makefile, that gets used for compilation. Maybe helpful:

# This file contains generic rules to build many kinds of simple
# extension modules.  You only need to set a few variables and include
# this file, the rest will be done here.
#
# Use the following layout for your Makefile:
#
#   [variable assignments, see below]
#
#   PG_CONFIG = pg_config
#   PGXS := $(shell $(PG_CONFIG) --pgxs)
#   include $(PGXS)
#
#   [custom rules, rarely necessary]
#
# Set one of these three variables to specify what is built:
#
#   MODULES -- list of shared-library objects to be built from source files
#     with same stem (do not include library suffixes in this list)
#   MODULE_big -- a shared library to build from multiple source files
#     (list object files in OBJS)
#   PROGRAM -- an executable program to build (list object files in OBJS)
#
# The following variables can also be set:
#
#   EXTENSION -- name of extension (there must be a $EXTENSION.control file)
#   MODULEDIR -- subdirectory of $PREFIX/share into which DATA and DOCS files
#     should be installed (if not set, default is "extension" if EXTENSION
#     is set, or "contrib" if not)
#   DATA -- random files to install into $PREFIX/share/$MODULEDIR
#   DATA_built -- random files to install into $PREFIX/share/$MODULEDIR,
#     which need to be built first
#   DATA_TSEARCH -- random files to install into $PREFIX/share/tsearch_data
#   DOCS -- random files to install under $PREFIX/doc/$MODULEDIR
#   SCRIPTS -- script files (not binaries) to install into $PREFIX/bin
#   SCRIPTS_built -- script files (not binaries) to install into $PREFIX/bin,
#     which need to be built first
#   HEADERS -- files to install into $(includedir_server)/$MODULEDIR/$MODULE_big
#   HEADERS_built -- as above but built first (but NOT cleaned)
#   HEADERS_$(MODULE) -- files to install into
#     $(includedir_server)/$MODULEDIR/$MODULE; the value of $MODULE must be
#     listed in MODULES or MODULE_big
#   HEADERS_built_$(MODULE) -- as above but built first (also NOT cleaned)
#   REGRESS -- list of regression test cases (without suffix)
#   REGRESS_OPTS -- additional switches to pass to pg_regress
#   TAP_TESTS -- switch to enable TAP tests
#   ISOLATION -- list of isolation test cases
#   ISOLATION_OPTS -- additional switches to pass to pg_isolation_regress
#   NO_INSTALLCHECK -- don't define an installcheck target, useful e.g. if
#     tests require special configuration, or don't use pg_regress
#   EXTRA_CLEAN -- extra files to remove in 'make clean'
#   PG_CPPFLAGS -- will be prepended to CPPFLAGS
#   PG_CFLAGS -- will be appended to CFLAGS
#   PG_CXXFLAGS -- will be appended to CXXFLAGS
#   PG_LDFLAGS -- will be prepended to LDFLAGS
#   PG_LIBS -- will be added to PROGRAM link line
#   PG_LIBS_INTERNAL -- same, for references to libraries within build tree
#   SHLIB_LINK -- will be added to MODULE_big link line
#   SHLIB_LINK_INTERNAL -- same, for references to libraries within build tree
#   PG_CONFIG -- path to pg_config program for the PostgreSQL installation
#     to build against (typically just "pg_config" to use the first one in
#     your PATH)
#
# Better look at some of the existing uses for examples...





SELECT typname, oid, typlen, format_type(oid, NULL) AS sql_name
FROM pg_type
WHERE format_type(oid, NULL) = 'integer' OR format_type(oid, NULL) = 'bigint' OR format_type(oid, NULL) = 'date' OR typname = 'timestamp' OR typname = 'varchar' or typname = 'numeric' OR format_type(oid, NULL) = 'smallint' OR format_type(oid, NULL) = 'real' OR format_type(oid, NULL) = 'double precision' OR typname = 'time' OR format_type(oid, NULL) = 'text' OR typname = 'bool';
  typname  | oid  | typlen |          sql_name
-----------+------+--------+-----------------------------
 bool      |   16 |      1 | boolean
 char      |   18 |      1 | "char"
 int8      |   20 |      8 | bigint
 int2      |   21 |      2 | smallint
 int4      |   23 |      4 | integer
 text      |   25 |     -1 | text
 float4    |  700 |      4 | real
 float8    |  701 |      8 | double precision
 bpchar    | 1042 |     -1 | character
 varchar   | 1043 |     -1 | character varying
 date      | 1082 |      4 | date
 time      | 1083 |      8 | time without time zone
 timestamp | 1114 |      8 | timestamp without time zone
 numeric   | 1700 |     -1 | numeric




Get overview of all tables and foreign tables with options:

 SELECT c.relname AS "Table",
        CASE WHEN c.relkind = 'r' THEN 'ordinary table'
             WHEN c.relkind = 'v' THEN 'view'
             WHEN c.relkind = 'm' THEN 'materialized view'
             WHEN c.relkind = 'f' THEN 'foreign table'
             ELSE 'other' END AS "Type",
        pg_size_pretty(pg_total_relation_size(c.oid)) AS "Size",
         ft.ftoptions as "fdw options"
 FROM pg_catalog.pg_class c
 JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace LEFT JOIN pg_foreign_table as ft ON c.oid = ft.ftrelid
 WHERE c.relkind IN ('r', 'v', 'm', 'f')
 AND n.nspname NOT IN ('information_schema', 'pg_catalog')
 ORDER BY n.nspname, c.relname;





CREATE FOREIGN TABLE IF NOT EXISTS sheet_sf0001_lineitem(
    l_orderkey      bigint,
    l_partkey       integer,
    l_suppkey       integer,
    l_linenumber    integer,
    l_quantity      numeric(12,2),
    l_extendedprice numeric(12,2),
    l_discount      numeric(12,2),
    l_tax           numeric(12,2),
    l_returnflag    char(1),
    l_linestatus    char(1),
    l_shipdate      date,
    l_commitdate    date,
    l_receiptdate   date,
    l_shipinstruct  char(25),
    l_shipmode      char(10),
    l_comment       varchar(44)
) SERVER dummy
OPTIONS (filepath '/pg_sheet_fdw/test/sf0001/lineitem.xlsx', sheetname '');

CREATE FOREIGN TABLE IF NOT EXISTS sheet_sf0001_customer  ( C_CUSTKEY INTEGER,
    C_NAME        VARCHAR(25) NOT NULL,
    C_ADDRESS     VARCHAR(40) NOT NULL,
    C_NATIONKEY   INTEGER NOT NULL,
    C_PHONE       CHAR(15) NOT NULL,
    C_ACCTBAL     DECIMAL(15,2)   NOT NULL,
    C_MKTSEGMENT  CHAR(10) NOT NULL,
    C_COMMENT     VARCHAR(117) NOT NULL) SERVER dummy
                                        OPTIONS (filepath '/pg_sheet_fdw/test/sf0001/customer.xlsx', sheetname '');


-- TPC-H Query 3

select l.l_orderkey,
       sum( l.l_extendedprice * (1 - l.l_discount )) as revenue,
       o.o_orderdate,
       o.o_shippriority
  from sheet_sf0001_customer as c,
       pg1_sf0001_orders as o,
       sheet_sf0001_lineitem as l
where 1 = 1
  and c.c_custkey = o.o_custkey
  and l.l_orderkey = o.o_orderkey
  and c.c_mktsegment = 'BUILDING'
  and o.o_orderdate < date '1995-03-15'
  and l.l_shipdate > date '1995-03-15'
group by l.l_orderkey,
         o.o_orderdate,
         o.o_shippriority
order by sum( l.l_extendedprice * (1 - l.l_discount )) desc,
         o.o_orderdate;
